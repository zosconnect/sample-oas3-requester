*PROCESS LIMITS(EXTNAME(8));
*PROCESS NOT(!);
*PROCESS DISPLAY(STD);
 /*********************************************************************
  * Copyright IBM Corp. 2024, 2025
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *     http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing
  * , software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
  * either express or implied. See the License for the specific
  * language governing permissions and limitations under the
  * License.
  *********************************************************************/

 BAQHRBKB: PROC() options(MAIN);
    /******************************************************************
     * BAQHRBKB                                                       *
     *                                                                *
     * Operation Parameters:                                          *
     *      GARB - Get All Redbooks                                   *
     *      GRBK - Get Redbook                                        *
     *      CRBK - Create Redbook                                     *
     *      PRBK - Patch Redbook                                      *
     *      MRBK - Merge Redbook                                      *
     *                                                                *
     * Pass in via JCL APARM statement, E.g:                          *
     *    //RBKRUN EXEC PROC=IMSBATCH,                                *
     *                  APARM='GARB'                                  *
     *                                                                *
     * Optionally specify DEBUG for more diagnostics, E.g:            *
     *    //RBKRUN EXEC PROC=IMSBATCH,                                *
     *                  APARM='GARB DEBUG'                            *
     *                                                                *
     * Calls RedbookAPI endpoint application operations.              *
     ******************************************************************/

    // API requester Host API required copy books
    %include BAQHAREP;
    %include BAQHCONP;

    // IMS copybooks and constants
    %include BAQHCIMS;

    // API_INFO for Operation getRedbook
    %include RBK00I01;

    // API_INFO for Operation createRedbook
    %include RBK01I01;

    // API_INFO for Operation patchRedbook
    %include RBK02I01;

    // API_INFO for Operation mergeRedbook
    %include RBK03I01;

    // API_INFO for Operation getAllRedbooks
    %include RBK04I01;

    // Request structure for Operation getRedbook
    %include RBK00Q01;

    // Request structure for Operation createRedbook
    %include RBK01Q01;

    // Request structure for Operation patchRedbook
    %include RBK02Q01;

    // Request structure for Operation mergeRedbook
    %include RBK03Q01;

    // Request structure for Operation getAllRedbooks
    %include RBK04Q01;

    // Response structure for Operation getRedbook
    %include RBK00P01;

    // Response structure for Operation createRedbook
    %include RBK01P01;

    // Response structure for Operation patchRedbook
    %include RBK02P01;

    // Response structure for Operation mergeRedbook
    %include RBK03P01;

    // Response structure for Operation getAllRedbooks
    %include RBK04P01;


    // Holder of an API_INFO structure
  DCL 01 api_info,
         03 BAQ_API_INFO_EYE        CHAR(4) INIT('BAQA'),
         03 BAQ_API_INFO_LENGTH     FIXED BIN(32) ALIGNED
            INIT(1311) UNSIGNED,
         03 BAQ_API_INFO_VERSION    FIXED BIN(32) ALIGNED
            INIT(2) UNSIGNED,
         03 BAQ_API_INFO_RESERVED01 FIXED BIN(32) ALIGNED
            INIT(0) UNSIGNED,
         03 BAQ_API_NAME            CHAR(255)
            INIT(''),
         03 BAQ_API_NAME_LEN        FIXED BIN(32) ALIGNED
            INIT(0) UNSIGNED,
         03 BAQ_API_PATH            CHAR(255)
            INIT(''),
         03 BAQ_API_PATH_LEN        FIXED BIN(32) ALIGNED
            INIT(0) UNSIGNED,
         03 BAQ_API_METHOD          CHAR(255)
            INIT(''),
         03 BAQ_API_METHOD_LEN      FIXED BIN(32) ALIGNED
            INIT(0) UNSIGNED,
         03 BAQ_API_OPERATION       CHAR(255)
            INIT(''),
         03 BAQ_API_OPERATION_LEN   FIXED BIN(32) ALIGNED
            INIT(0) UNSIGNED,
         03 BAQ_API_MEDIA_TYPE      CHAR(255)
            INIT(''),
         03 BAQ_API_MEDIA_TYPE_LEN  FIXED BIN(32) ALIGNED
            INIT(0) UNSIGNED;

    // Data Area name to get
    DCL data_area_name          CHAR(16);

    // Set DEBUG state, 1 for Tracing, 0 without
    DCL debug                   UNSIGNED FIXED BIN(32) INIT(0);

    // Handle parameters passed in from APARM
    DCL 01 parm_buffer,
           03 parm_length       FIXED BIN(15),
           03 parm_data,
              05 operation      CHAR(4),
              05 *              CHAR(1),
              05 debug          CHAR(5),
              05 *              CHAR(90);

    // General Index Count
    DCL i                       UNSIGNED FIXED BIN(32);
    DCL j                       UNSIGNED FIXED BIN(32);

    // Display this message to standard out
    DCL display_message         CHAR(78) VARYING INIT(REPEAT(' ', 77));

    // General Return Code to track success through execution
    DCL rc                      UNSIGNED FIXED BIN(32) INIT(0);
    DCL OK                      UNSIGNED FIXED BIN(32) INIT(0);
    DCL FAILED                  UNSIGNED FIXED BIN(32) INIT(1);

    // Call return code
    DCL baq_rc                  UNSIGNED FIXED BIN(32);

    // The address of a returned Data Area Element
    DCL element                 POINTER INIT(SYSNULL());

    // Length of element for BAQGETN call
    DCL element_length          FIXED BIN(31) INIT(0);

    // For IMS Parm Count
    DCL THREE                   FIXED BIN(31) INIT(3);

    // Obtain the APARM
    AIB_CONTROL.AIB_LEN = SIZE(AIB_CONTROL);
    AIB_CONTROL.AIB_OUT_AREA_LEN = SIZE(INQY_IO_AREA);
    CALL AIBTDLI(THREE, DLI_INQY, AIB_CONTROL, INQY_IO_AREA);

    IF (AIB_RETURN_CODE != 0) THEN DO;
       DISPLAY('RETURN CODE = ' || AIB_RETURN_CODE);
       DISPLAY('REASON CODE = ' || AIB_REASON_CODE);
       RETURN;
    END;

    INQY_ENVIRON_FIELDS = INQY_ENVIRON_DATA;
    parm_length = INQY_LEN_APARM;
    parm_data =  INQY_APARM;

    /*----------------------------------------------------------------*
     * a_mainline
     *----------------------------------------------------------------*/
    IF parm_length < 4 THEN DO;
       DISPLAY('PLEASE SPECIFY OPERATION TO CALL AS PARAMETER');
       DISPLAY('VALID OPERATIONS ARE GARB, GRBK, CRBK, PRBK and MRBK.');
       RETURN;
    END;

    IF parm_buffer.parm_data.debug = 'DEBUG' THEN
       debug = 1;

    IF debug = 1 THEN
       DISPLAY(operation || ' a_mainline Entry.');

    /*
     * Initialise the Host API and acquire a connection to
     * a z/OS Connect server instance
     */
    CALL b_init;

    /*
     * If a connection was gained make a BAQEXEC call to a
     * remote endpoint API operation
     */
    IF rc = OK THEN DO;
       CALL c_execute;

       // Free any resources used by BAQEXEC
       CALL x_free;

       // Terminate the connection to the z/OS Connect server
       CALL x_term;
    END;

    IF debug = 1 THEN
       DISPLAY(operation || ' a_mainline Exit. RC=' || rc);

    RETURN;

    /*----------------------------------------------------------------*
     * b_init
     *
     * Initialize the program to call the API
     *----------------------------------------------------------------*/
    b_init: PROC;

       IF debug = 1 THEN
          DISPLAY(operation || ' b_init Entry');

       rc = OK;

       /*
        * Initialise the Host API and get a connection to the
        * z/OS Connect server
        */
       call x_init;

       IF debug = 1 THEN
          DISPLAY(operation || ' b_init Exit' || rc);

    END b_init;

    /*----------------------------------------------------------------*
     * c_execute
     *
     * Call the required API operation
     *----------------------------------------------------------------*/
    c_execute: PROC;

       IF debug = 1 THEN
          DISPLAY(operation || ' c_execute Entry');

       // GARB
       IF operation = 'GARB' THEN
          CALL ca_get_all_redbooks;

       // GRBK Title[, author ]
       ELSE IF operation = 'GRBK' THEN
          CALL cb_get_redbook;

       // CRBK Title
       ELSE IF operation = 'CRBK' THEN
          CALL cc_create_redbook;

       // PRBK Title
       ELSE IF operation = 'PRBK' THEN
          CALL cd_patch_redbook;

       // MRBK Title
       ELSE IF operation = 'MRBK' THEN
          CALL ce_merge_redbook;

       // Unknown request
       ELSE DO;
          DISPLAY('OPERATION ' || operation || ' UNKNOWN');
          rc = FAILED;
       END;

       IF debug = 1 THEN
          DISPLAY(operation || ' c_execute Exit' || rc);

    END c_execute;

    /*----------------------------------------------------------------*
     * ca_get_all_redbooks
     *
     * Operation getAllRedbooks
     *
     * Sets the content of the BAQBASE_RBK04Q01 Request structure
     * ready for the BAQEXEC Call. The call is then made to the
     * API End Point (EP) via BAQEXEC and the z/OS Connect server.
     *
     * Upon success, the BAQBASE_RBK04P01 structure is returned
     * and dependent of the EP HTTP Status Code a DATA AREA element
     * is addressed and processed.
     *----------------------------------------------------------------*/
    ca_get_all_redbooks: PROC;

       IF debug = 1 THEN
          DISPLAY(operation || ' ca_get_all_redbooks Entry');

       // Prepare the request
       BAQ_REQ_BASE_ADDRESS = ADDR(BAQBASE_RBK04Q01);
       BAQ_REQ_BASE_LENGTH = SIZE(BAQBASE_RBK04Q01);

       /*
        * For this request we want to get all Redbook Inventory
        * and not the inventory for a particular author so we set
        * the author_existence flag to 0 to tell z/OS Connect that
        * the optional author parameter is not set.
        */
       BAQBASE_RBK04Q01.author_existence = 0;

       /*
        * Call the API
        * Passing the address of the API_INFO structure required for the
        * BAQEXEC call. Procedure x_exec is a reusable routine that is
        * used for all API calls.
        */
       api_info = BAQ_API_INFO_RBK04I01;
       CALL x_exec;

       /*
        * Check that the call was successful, if not exit
        * Procedure x_exec has displayed the error responses
        */
       IF baq_rc = BAQ_ERROR THEN DO;
          DISPLAY(operation || ' ca_get_all_redbooks BAQEXEC problem');
          DISPLAY(SUBSTR(BAQ_ZCON_RETURN_MESSAGE,
                         1, BAQ_ZCON_RETURN_MESSAGE_LEN));
          rc = FAILED;
          GO TO ca_999;
       END;

       IF baq_rc = BAQ_ERROR THEN DO;
          DISPLAY(operation || ' ca_get_all_redbooks BAQEXEC problem');
          DISPLAY(SUBSTR(BAQ_RESP_STATUS_MESSAGE,
                         1, BAQ_RESP_STATUS_MESSAGE_LEN));
          rc = FAILED;
          GO TO ca_999;
       END;

       /*
        * z/OS Connect has successfully called the remote endpoint API and
        * the API has returned an HTTP status code that was defined in the
        * Open API document for the called operation. This could be an
        * error HTTP status code, but as long as it is defined in the OAS
        * document then z/OS Connect sees this as a successful call so now
        * we must address the returned base structure and interrogate the
        * returned responses in more detail
        *
        * The address of the returned BAQBASE structure is returned in
        * the BAQ_RESPONSE_AREA so set the structure to that address
        */
        BAQBASE_RBK04P01_PTR = BAQ_RESP_BASE_ADDRESS;

       /*
        * For this operation the OAS document defines two responses
        * 200-OK and 404-NOTFOUND, if the remote endpoint application
        * returns any other HTTP status code then a status of
        * BAQ_WARNING is returned and the endpoint response is returned
        * in BAQ_RESP_STATUS_MESSAGE, first 1024 characters.
        *
        * If we have reached here we know the remote endpoint status
        * code is either 404-NOTFOUND or 200-OK. Depending on the status
        * code this determines which Data Area has been returned. See
        * z/OS connect documentation for details on what a Data Area is.
        * In short it is an area of memory that is described by a
        * generated 01 level data structure, it is dynamic in length and
        * used to reference the returned data on a per HTTP status code
        * bases and also for referencing dynamic length arrays.
        */

       /*
        * Check the remote endpoint HTTP status code and check that a
        * response was received, let's check the NOTFOUND case first.
        */
       IF BAQ_RESP_STATUS_CODE = 404 THEN DO;
          IF BAQBASE_RBK04P01.responseCode404_existence > 0 THEN DO;

             /*
              * The Redbook API provided a RedbookNotFound response body
              * in a Data Area, the name of that Data Area is located in
              * responseCode404_dataarea in the BAQBASE data structure.
              * Set this name in to data_area_name and use the common
              * routines x_get_data_area_element and set the expected
              * length of the returned data in element_length.
              */
             data_area_name = BAQBASE_RBK04P01.responseCode404_dataarea;
             element_length = SIZE(RBK04P01_responseCode404);

             CALL x_get_data_area_element(data_area_name, element,
                                          element_length);

             // If rc is failed the BAQGETN call failed
             IF rc = FAILED THEN GO TO ca_999;

             /*
              * BAQGETN has worked and returned the address of the Data
              * Area that contains the RBK04P01_responseCode404 data
              * structure.  Lets address that and display the returned
              * message which should indicate that there are no
              * Redbooks in the repository.
              *
              * The RBK04P01_responseCode404 also contains a dynamic
              * array Data Area of authors Redbooks, but for this
              * operation this array is not set
              */

             RBK04P01_responseCode404_PTR = element;
             display_message = operation ||
                ' API EP returned HTTP Status Code ' ||
                BAQ_RESP_STATUS_CODE ||
                '. MESSAGE ' || RBK04P01_responseCode404.message;

             CALL x_write_response_msg;
          END;
          ELSE DO;
             /*
              * 404 was returned but there is no RedbookNotFound
              * response body
              */
             display_message = operation ||
                ' API EP returned HTTP Status Code ' ||
                BAQ_RESP_STATUS_CODE ||
                '. NO Response Body';

             CALL x_write_response_msg;
          END;
       END;

       /*
        * Process each returned Redbook. Rather than a single entity in
        * the returned Data Area in this case the OAS response body is
        * an array so rather than a '_existence' flag we have '_num'
        * count that details how many elements exist in the array and
        * we will use x_get_data_area_element to fetch each one in turn.
        */
       IF BAQ_RESP_STATUS_CODE = 200 THEN DO;
          IF BAQBASE_RBK04P01.responseCode200_num > 0 THEN DO;
             display_message = operation ||
                ' Redbook Inventory';
             CALL x_write_response_msg;

             DO i = 1 TO BAQBASE_RBK04P01.responseCode200_num BY 1
                      WHILE (rc = OK);
                CALL caa_get_each_redbook(i);
             END;
          END;
          ELSE DO;
             display_message = operation ||
                ' EXEC API EP - No Redbooks returned';
             CALL x_write_response_msg;
          END;
       END;

 ca_999:
       IF debug = 1 THEN
          DISPLAY(operation || ' ca_get_all_redbooks Exit' || rc);

    END ca_get_all_redbooks;

    /*----------------------------------------------------------------*
     * caa_get_each_redbook
     *
     * Gets each book returned by the remote End Point Service by using
     * BAQGETN (Get Next) and displays the Redbook details.
     *----------------------------------------------------------------*/
    caa_get_each_redbook: PROC(i);
       DCL i UNSIGNED FIXED BIN(32);

       IF debug = 1 THEN
          DISPLAY(operation ||
             ' caa_get_each_redbook(' || i || ') Entry');

       data_area_name = BAQBASE_RBK04P01.responseCode200_dataarea;
       element_length = SIZE(RBK04P01_responseCode200);

       CALL x_get_data_area_element(data_area_name, element,
                                    element_length);

       // If rc is failed the BAQGETN call failed
       IF rc = FAILED THEN GO TO caa_999;

       /*
        * We have fetched the Redbook from the Data Area so set the
        * address of the 01 level data structure.
        */
       RBK04P01_responseCode200_PTR = element;

       /*
        * For simplicity lets display the content of the Redbook data
        * structure.
        *
        * Note that optional fields have an '_existence' field to denote
        * if the field exists or not.
        */

       IF debug = 1 THEN
          DISPLAY(operation || ' Redbook number ' || i);

       display_message = operation || ' Title ' ||
          RBK04P01_responseCode200.title;

       CALL x_write_response_msg;

       /*
        * Redbooks typically have more than one author so these are
        * contained in an array in the OAS Redbook schema and thus
        * returned in a dynamic Data Area. If the OAS Schema defined a
        * 'maxItems' and this is less than the property
        * 'inlineMaxOccursLimit', set in the Gradle Plugin options.yaml,
        * then the array would be inlined in the Redbook data
        * structure. But here we use a dynamic length array again.
        */
       DO j = 1 TO RBK04P01_responseCode200.authors_num BY 1
                WHILE (rc = OK);
          CALL caaa_get_each_author(j);
       END;

       IF debug = 1 THEN
          DISPLAY(operation || ' Status ' ||
                  RBK04P01_responseCode200.status);

       IF RBK04P01_responseCode200.publicationDate_existence > 0 THEN
       DO;
          IF debug = 1 THEN
             DISPLAY(operation || ' Publication Date ' ||
                     RBK04P01_responseCode200.publicationDate);
       END;

       DISPLAY(operation);

 caa_999:
       IF debug = 1 THEN
          DISPLAY(operation || ' caa_get_each_redbook Exit' || rc);

    END caa_get_each_redbook;

    /*----------------------------------------------------------------*
     * caaa_get_each_author
     *
     * Gets each author returned by the remote API by using
     * BAQGETN (Get Next) and displays the Author.
     *----------------------------------------------------------------*/
    caaa_get_each_author: PROC(j);
       DCL j UNSIGNED FIXED BIN(32);

       IF debug = 1 THEN
          DISPLAY(operation ||
             ' caaa_get_each_author(' || j || ') Entry');

       data_area_name = RBK04P01_responseCode200.authors_dataarea;
       element_length = SIZE(RBK04P01_authors);

       CALL x_get_data_area_element(data_area_name, element,
                                    element_length);

       // If rc is failed the BAQGETN call failed
       IF rc = FAILED THEN GO TO caaa_999;

       /*
        * We have fetched the Author from the Data Area so set the
        * address of the 01 level data structure.
        */
       RBK04P01_authors_PTR = element;

       IF debug = 1 THEN
          DISPLAY(operation || ' Author ' || j);

       IF debug = 1 THEN
          DISPLAY(operation || ' ' ||
                  RBK04P01_authors.firstName || ' ' ||
                  RBK04P01_authors.lastName);

 caaa_999:
       IF debug = 1 THEN
          DISPLAY(operation || ' caaa_get_each_author Exit' || rc);

    END caaa_get_each_author;

    /*----------------------------------------------------------------*
     * cb_get_redbook
     *
     * Operation getRedbook
     *
     * Sets the content of the BAQBASE_RBK00Q01 Request structure
     * ready for the BAQEXEC Call. The call is then made to the
     * API End Point (EP) via BAQEXEC and the z/OS Connect server.
     *
     * Upon success, the BAQBASE_RBK00P01 structure is returned
     * and dependent of the EP HTTP Status Code a DATA AREA element
     * is got and processed.
     *----------------------------------------------------------------*/
    cb_get_redbook: PROC;

       IF debug = 1 THEN
          DISPLAY(operation || ' cb_get_redbook Entry');

       // Prepare the request for sending
       BAQ_REQ_BASE_ADDRESS = ADDR(BAQBASE_RBK00Q01);
       BAQ_REQ_BASE_LENGTH = SIZE(BAQBASE_RBK00Q01);

       /*
        * First we make sure the whole request structure is initialised
        * so that the request is only sending intended values
        */
       BAQBASE_RBK00Q01 = '';

       /*
        * Now populate the fields of the request structure with the
        * values for the new book which we are going to create
        */

       // Set the title
       BAQBASE_RBK00Q01.title = 'Accelerate Mainframe Application '
         || 'Modernization with Hybrid Cloud';

 cb_020:
       // Call the API
       api_info = BAQ_API_INFO_RBK00I01;
       CALL x_exec;

       /*
        * Check that the call was successful, if not exit
        * Procedure x_exec has displayed the error responses
        */
       IF baq_rc = BAQ_ERROR THEN DO;
          DISPLAY(operation || ' cb_get_redbook BAQEXEC problem');
          DISPLAY(SUBSTR(BAQ_ZCON_RETURN_MESSAGE,
                         1, BAQ_ZCON_RETURN_MESSAGE_LEN));
          rc = FAILED;
          GO TO cb_999;
       END;

       IF baq_rc = BAQ_ERROR THEN DO;
          DISPLAY(operation || ' cb_get_redbook BAQEXEC problem');
          DISPLAY(SUBSTR(BAQ_RESP_STATUS_MESSAGE,
                         1, BAQ_RESP_STATUS_MESSAGE_LEN));
          rc = FAILED;
          GO TO cb_999;
       END;

       /*
        * Successful call, address the base structure BAQBASE_RBK00P01
        */
       BAQBASE_RBK00P01_PTR = BAQ_RESP_BASE_ADDRESS;

 cb_030:
       /*
        * Process a 500 response code, in this case the response will
        * be in BAQ_RESP_STATUS_MSG.
        */
       IF BAQ_RESP_STATUS_CODE = 500 THEN DO;
          display_message = operation ||
                ' API EP returned HTTP Status Code ' ||
                BAQ_RESP_STATUS_CODE ||
                '. Internal Server Error.';

          CALL x_write_response_msg;
          rc = FAILED;
          GO TO cb_999;
       END;

 cb_040:
       /*
        * Process a 404 response code, in this case the response
        * will be in data structure RBK00P01_responseCode404
        * accessed via its Data Area responseCode404_dataarea of
        * BAQBASE_RBK00P01 using BAQGETN
        */
       IF BAQ_RESP_STATUS_CODE = 404 THEN DO;

          display_message = operation ||
            ' API EP returned HTTP Status Code ' ||
            BAQ_RESP_STATUS_CODE ||
            '. Redbook not found.';

          CALL x_write_response_msg;

          // Display any message returned with the 404
          IF BAQBASE_RBK00P01.responseCode404_existence > 0 THEN DO;

             data_area_name = BAQBASE_RBK00P01.responseCode404_dataarea;
             element_length = SIZE(RBK00P01_responseCode404);

             CALL x_get_data_area_element(data_area_name, element,
                                          element_length);

             // If rc is failed the BAQGETN call failed
             IF rc = FAILED THEN GO TO cb_999;

             /*
              * We have fetched the RBK00P01_responseCode404 structure
              * from the Data Area so set the address
              */
             RBK00P01_responseCode404_PTR = element;

             IF length(RBK00P01_responseCode404.message) > 1 THEN DO;

                display_message = operation ||
                  ' API EP returned HTTP Status Code ' ||
                  BAQ_RESP_STATUS_CODE ||
                  '. MESSAGE ' || RBK02P01_responseCode404.message;

                CALL x_write_response_msg;
                rc = FAILED;
                GO TO cb_999;
             END;
          END;
       END;

 cb_050:
       /*
        * Process the returned Redbook, check the
        * responseCode200_existence is 1 and if so use
        * responseCode200_dataarea to get the returned Redbook
        * in to data structure RBK00P01_responseCode200 and
        * display the content
        */
       IF BAQ_RESP_STATUS_CODE = 200 THEN DO;
          display_message = operation ||
            ' API EP returned HTTP Status Code ' ||
            BAQ_RESP_STATUS_CODE ||
            '. Found Redbook.';

          CALL x_write_response_msg;

          // Display any message returned with the 404
          IF BAQBASE_RBK00P01.responseCode200_existence > 0 THEN DO;

             // A Redbook was returned so let's get the data for it
             data_area_name = BAQBASE_RBK00P01.responseCode200_dataarea;
             element_length = SIZE(RBK00P01_responseCode200);

             CALL x_get_data_area_element(data_area_name, element,
                                          element_length);

             // If rc is failed the BAQGETN call failed
             IF rc = FAILED THEN GO TO cb_999;

             /*
              * We have fetched the Redbook from the Data Area so set
              * the address of the 01 level Redbook data structure.
              */
             RBK00P01_responseCode200_PTR = element;

             display_message = operation || ' Title ' ||
                  RBK00P01_responseCode200.title;

             CALL x_write_response_msg;
          END;
       END;

 cb_999:
       IF debug = 1 THEN
          DISPLAY(operation || ' cb_get_redbook Exit' || rc);

    END cb_get_redbook;


    /*----------------------------------------------------------------*
     * cc_create_redbook
     *
     * Operation createRedbook
     *
     * Sets the content of the BAQBASE_RBK01Q01 Request structure
     * ready for the BAQEXEC Call. The call is then made to the
     * API End Point (EP) via BAQEXEC and the z/OS Connect server.
     *
     * Upon success, the BAQBASE_RBK01P01 structure is returned
     * and dependent of the EP HTTP Status Code a DATA AREA element
     * is got and processed.
     *----------------------------------------------------------------*/
    cc_create_redbook: PROC;

       IF debug = 1 THEN
          DISPLAY(operation || ' cc_create_redbook Entry');

       /*
        * First we make sure the whole request structure is initialised
        * so that the request is only sending intended values
        */
       BAQBASE_RBK01Q01 = '';

       /*
        * Now populate the fields of the request structure with the
        * values for the new book which we are going to create
        */

       // Start with the path parameter which will create the new book
       BAQBASE_RBK01Q01.requestPathParameters.title = 'Accelerate '
         || 'Mainframe Application Modernization with Hybrid Cloud';

       // Now populate the remaining fields of the book structure
       BAQBASE_RBK01Q01.requestBody.title  =
         BAQBASE_RBK01Q01.requestPathParameters.title;

       BAQBASE_RBK01Q01.requestBody.status = 'PUBLISHED';

       BAQBASE_RBK01Q01.requestBody.publicationDate_existence = 1;
       BAQBASE_RBK01Q01.requestBody.publicationDate =
         '2023-03-31T00:00:00Z';

       BAQBASE_RBK01Q01.requestBody.formNumber = 'REDP-5705-00';

       BAQBASE_RBK01Q01.requestBody.documentType_existence = 1;
       BAQBASE_RBK01Q01.requestBody.documentType ='PDF';

       BAQBASE_RBK01Q01.requestBody.sizeMB_existence = 1;
       BAQBASE_RBK01Q01.requestBody.sizeMB = 6.62;

       BAQBASE_RBK01Q01.requestBody.url_existence = 1;
       BAQBASE_RBK01Q01.requestBody.url =
         'https://www.redbooks.ibm.com/redpapers/pdfs/redp5705.pdf';

       BAQBASE_RBK01Q01.requestBody.authors_num = 10;
       BAQBASE_RBK01Q01.requestBody.authors_dataarea =
         'AUTHOR-DATA-AREA';

 cc_020:
       /*
        * We use BAQPUTN to add the authors to the book and this is
        * performed in a separate section.
        */
       CALL ccaa_put_each_author;
       IF rc = FAILED THEN GO TO cc_999;

 cc_030:
       /*
        * The request data for our new book is now complete and we are
        * ready to send it to the API endpoint.
        */
       BAQ_REQ_BASE_ADDRESS = ADDR(BAQBASE_RBK01Q01);
       BAQ_REQ_BASE_LENGTH = SIZE(BAQBASE_RBK01Q01);

       /*
        * Passing the address of the API_INFO structure required for the
        * BAQEXEC call. Procedure x_exec is a reuseable routine that is
        * used for all API calls.
        */
       api_info = BAQ_API_INFO_RBK01I01;
       CALL x_exec;

       /*
        * Check that the call was successful, if not exit
        * Procedure x_exec has displayed the error responses
        */
       IF baq_rc = BAQ_ERROR THEN DO;
          DISPLAY(operation || ' cc_create_redbook BAQEXEC problem');
          DISPLAY(SUBSTR(BAQ_ZCON_RETURN_MESSAGE,
                         1, BAQ_ZCON_RETURN_MESSAGE_LEN));
          rc = FAILED;
          GO TO cc_999;
       END;

       IF baq_rc = BAQ_ERROR THEN DO;
          DISPLAY(operation || ' cc_create_redbook BAQEXEC problem');
          DISPLAY(SUBSTR(BAQ_RESP_STATUS_MESSAGE,
                         1, BAQ_RESP_STATUS_MESSAGE_LEN));
          rc = FAILED;
          GO TO cc_999;
       END;

 cc_040:
       /*
        * z/OS Connect has successfully called the remote endpoint API
        * and the API has returned an HTTP status code that was defined
        * in the Open API document for the called operation. This could
        * be an error HTTP status code, but as long as it is defined in
        * the OAS document then z/OS Connect sees this as a successful
        * call so now we must address the returned base structure and
        * interrogate the returned responses in more detail
        *
        * The address of the returned BAQBASE structure is returned in
        * the BAQ-RESPONSE-AREA so set the structure to that address
        */
       BAQBASE_RBK01P01_PTR = BAQ_RESP_BASE_ADDRESS;

       // Check the HTTP status code
       IF BAQ_RESP_STATUS_CODE = 409 THEN DO;
          display_message = operation ||
                ' API EP returned HTTP Status Code ' ||
                BAQ_RESP_STATUS_CODE ||
                '. Redbook already exists.';

          CALL x_write_response_msg;
       END;

       IF BAQ_RESP_STATUS_CODE >= 200 &
          BAQ_RESP_STATUS_CODE < 300 THEN DO;
          display_message = operation ||
                ' API EP returned HTTP Status Code ' ||
                BAQ_RESP_STATUS_CODE ||
                '. Created Redbook.';

          CALL x_write_response_msg;
       END;

 cc_999:
       IF debug = 1 THEN
          DISPLAY(operation || ' cc_create_redbook Exit' || rc);

    END cc_create_redbook;

    /*----------------------------------------------------------------*
     * ccaa_put_each_author
     *
     * Puts each author of the book by using the BAQPUTN (Put Next)
     * verb.
     *----------------------------------------------------------------*/
    ccaa_put_each_author: PROC;

       IF debug = 1 THEN
          DISPLAY(operation || ' ccaa_put_each_author Entry');

       /*
        * Setup the variables which X-PUT-DATA-AREA-ELEMENT will be
        * using to add authors to the authors data area
        */
       data_area_name = BAQBASE_RBK01Q01.requestBody.authors_dataarea;
       element = ADDR(RBK01Q01_authors);
       element_length = SIZE(RBK01Q01_authors);

       // Now add the authors to the request Data Area
       RBK01Q01_authors.firstName = 'Skyla';
       RBK01Q01_authors.firstName_existence = 1;
       RBK01Q01_authors.lastName = 'Loomis';
       RBK01Q01_authors.lastName_existence = 1;
       CALL x_put_data_area_element(data_area_name, element,
                                    element_length);

       RBK01Q01_authors.firstName = 'Kyle';
       RBK01Q01_authors.firstName_existence = 1;
       RBK01Q01_authors.lastName = 'Charlet';
       RBK01Q01_authors.lastName_existence = 1;
       CALL x_put_data_area_element(data_area_name, element,
                                    element_length);
       IF rc = FAILED THEN GO TO cc_aa_999;

       RBK01Q01_authors.firstName = 'Suman';
       RBK01Q01_authors.firstName_existence = 1;
       RBK01Q01_authors.lastName = 'Gopinath';
       RBK01Q01_authors.lastName_existence = 1;
       CALL x_put_data_area_element(data_area_name, element,
                                    element_length);
       IF rc = FAILED THEN GO TO cc_aa_999;

       RBK01Q01_authors.firstName = 'Peter';
       RBK01Q01_authors.firstName_existence = 1;
       RBK01Q01_authors.lastName = 'McCaffrey';
       RBK01Q01_authors.lastName_existence = 1;
       CALL x_put_data_area_element(data_area_name, element,
                                    element_length);
       IF rc = FAILED THEN GO TO cc_aa_999;

       RBK01Q01_authors.firstName = 'Tim';
       RBK01Q01_authors.firstName_existence = 1;
       RBK01Q01_authors.lastName = 'Brooks';
       RBK01Q01_authors.lastName_existence = 1;
       CALL x_put_data_area_element(data_area_name, element,
                                    element_length);
       IF rc = FAILED THEN GO TO cc_aa_999;

       RBK01Q01_authors.firstName = 'Juergen';
       RBK01Q01_authors.firstName_existence = 1;
       RBK01Q01_authors.lastName = 'Holtz';
       RBK01Q01_authors.lastName_existence = 1;
       CALL x_put_data_area_element(data_area_name, element,
                                    element_length);
       IF rc = FAILED THEN GO TO cc_aa_999;

       RBK01Q01_authors.firstName = 'Bryant';
       RBK01Q01_authors.firstName_existence = 1;
       RBK01Q01_authors.lastName = 'Panyarachun';
       RBK01Q01_authors.lastName_existence = 1;
       CALL x_put_data_area_element(data_area_name, element,
                                    element_length);
       IF rc = FAILED THEN GO TO cc_aa_999;

       RBK01Q01_authors.firstName = 'Purvi';
       RBK01Q01_authors.firstName_existence = 1;
       RBK01Q01_authors.lastName = 'Patel';
       RBK01Q01_authors.lastName_existence = 1;
       CALL x_put_data_area_element(data_area_name, element,
                                    element_length);
       IF rc = FAILED THEN GO TO cc_aa_999;

       RBK01Q01_authors.firstName = 'Mythili';
       RBK01Q01_authors.firstName_existence = 1;
       RBK01Q01_authors.lastName = 'Venkatakrishnan';
       RBK01Q01_authors.lastName_existence = 1;
       CALL x_put_data_area_element(data_area_name, element,
                                    element_length);
       IF rc = FAILED THEN GO TO cc_aa_999;

       RBK01Q01_authors.firstName = 'Yichong';
       RBK01Q01_authors.firstName_existence = 1;
       RBK01Q01_authors.lastName = 'Yu';
       RBK01Q01_authors.lastName_existence = 1;
       CALL x_put_data_area_element(data_area_name, element,
                                    element_length);
       IF rc = FAILED THEN GO TO cc_aa_999;

  cc_aa_999:
       IF debug = 1 THEN
          DISPLAY(operation || ' ccaa_put_each_author Exit' || rc);

    END ccaa_put_each_author;

    /*----------------------------------------------------------------*
     * cd_patch_redbook
     *
     * Operation patchRedbook - RFC6902
     *
     * Sets the content of the BAQBASE_RBK02Q01 Request structure
     * ready for the BAQEXEC Call. The call is then made to the
     * RESTful End Point(EP) via BAQEXEC and the z/OS Connect server.
     *
     * Upon success, the BAQBASE_RBK02P01 structure is returned
     * and dependent of the EP HTTP Status Code a DATA AREA element
     * is got and processed.
     *----------------------------------------------------------------*/
    cd_patch_redbook: PROC;

       IF debug = 1 THEN
          DISPLAY(operation || ' cd_patch_redbook Entry');

       BAQBASE_RBK02Q01.requestBody = '';

       /*
        * Using the PATCH method in an API requests that a server object
        * is updated by a Patch Document on a field by field basis
        * rather then a complete replacement as would happen if using
        * the PUT method.
        *
        * This procedure will invoke the patchRedbook operation in the
        * Redbook management API. Operation patchRedbook uses media-type
        * application/json-patch+json which is defined by RFC 6902.
        * This RFC (https://www.rfc-editor.org/rfc/rfc6902) defines
        * the format of the patch document used to update the entity
        * via the Rest API in a server.
        *
        * We will see in procedure ce_merge_redbook the use of a patch
        * document that conforms to RFC 7396.
        * This RFC (https://www.rfc-editor.org/rfc/rfc7396) defines
        * a different patch document format and media-type
        * application/merge-patch+json.
        *
        * The RFC have different advantages and disadvantages,
        * z/OS Connect supports both standards and your API will
        * choose which to employ via the OpenApi definition of the API.
        *
        * The patch document is constructed by z/OS Connect based on the
        * settings made to the BAQBASE_RBK02Q01 request structure. The
        * COBOL Copybook used for both RFC are similar, but the array
        * support is limited in RFC 7396.
        *
        * Once z/OS Connect has constructed the patch document
        * conforming to the requested media-type (RFC) from the binary
        * COBOL structure this patch document is sent to the Rest API
        * endpoint service. This is received at its path/Patch function
        * and using appropriate function the patch document can be
        * applied to an entity.  See method patchRedbook in the Java
        * class RedbookResource.java for a Java example that uses
        * Jakarta JsonPatch classes to update a Java Redbook object.
        *
        * In this procedure we are going to set up a request that will
        * produce a patch document that will perform a number of updates
        * on a Redbook object. So for Redbook
        * 'ABCs of IBM zOS System Programming Volume 1' we are going
        * to update the Redbook to represent a fictitious new version of
        * the Redbook.
        *
        * 1. Update the URL of the Redbooks location.
        * 2. Update the owning departments Contact.
        * 3. Remove an author as the section has been replaced.
        * 4. Add a new Author to the Authors array
        * 5. Delete the size property as it is not used
        * 6. Add a 'version' property dynamically and set it to 2.
        *
        * These updates show a selection of Patch goals and how we
        * manipulate the operations Request structure to achieve these
        * goals.
        *
        * Lets setup the Request structure BAQBASE-RBK02Q01 then
        * make the call to z/OS Connect via the Host API verbs.
        */

       /*
        * 1. Update the URL of the redbook location
        *
        * Each property defined in the JSON Schema object when
        * translated to COBOL has a field of the same (or similar) name
        * with the suffix _patch_operation for a simple field or sub
        * structure or _patch_item for an array structure.
        *
        * In these fields we set the operation that we want to perform
        * on a particular field, if a -patch-operation field contains a
        * space then no update is made to the property on the Rest API
        * server.  See Patch product documentation for full details.
        *
        * Set the value 'U' for update to the url_patch_operation field
        * and set the new data.
        */
       BAQBASE_RBK02Q01.url_patch_operation = 'U';
       BAQBASE_RBK02Q01.url = 'http://newurl';

       /*
        * 2. Update the owning departments Contact.
        *
        * owningDepartment is a property of type object so this is an
        * example of updating an object within an object.
        *
        * Set the value 'U' for update to the contact-patch-operation
        * field and set the new data for contact.
        *
        * If we wanted to update the whole owningDepartment we could
        * set 'U' in the field ngDepartment-patch-operation and then
        * set the data in each field and the whole property object
        * will update.
        *
        * Note the owningDepartment-patch-operation field has
        * been truncated as the field name is too long to fit. To
        * shorten the -patch-operation to -pchop set the Requester
        * Gradle plugin option shortSuffix: yes. The field will then
        * generate as owningDepartment-pchop.  See the product
        * documentation for details on all the suffixes affected by
        * this option.
        */
        BAQBASE_RBK02Q01.contact_patch_operation = 'U';
        BAQBASE_RBK02Q01.contact = 'A. Contact';

       /*
        * 3. Remove an author as the section has been replaced.
        *
        * The Author property is of type array and the Redbook has a
        * number of authors. In this example update we want to remove
        * author 'Luiz Fadel' from the Redbook.
        *
        * Any array update is controlled by a field suffixed _patch_item
        * (or _pchitm if option shortSuffix is set to yes).
        * For our Author array we want to remove the second author
        * 'Luiz'. We set authors_patch_item to '2' to state we want to
        * change the second array element.
        *
        * _patch_item fields contain either a single array item number
        * or a list of array item numbers that are to be updated.
        * Numbers can be specified as ranges. See the product
        * documentation for full details.
        *
        * We set the authors-num field to 1 to state there is one array
        * element that we want to process. Any -num field should equal
        * the number of elements specified in the corresponding
        * _patch_item field. e.g. if authors_patch_item was '1, 5-7'
        * then authors_num would be 4.
        *
        * If we wanted to update the last name of the author we would
        * set 'U' in the last-name-patch-operation field and supply a
        * new name. Here we want to delete the entire Author item so we
        * set each _patch_operation field in the sub structure to 'D' to
        * state the entire array item is to be deleted.
        */
        BAQBASE_RBK02Q01.authors_patch_item = '2';
        BAQBASE_RBK02Q01.authors_num = 1;
        BAQBASE_RBK02Q01.authors_dataarea = "AUTHOR-DATA-AREA";

        data_area_name = BAQBASE_RBK02Q01.requestBody.authors_dataarea;
        element = ADDR(RBK02Q01_authors);
        element_length = SIZE(RBK02Q01_authors);

        RBK02Q01_authors = '';
        RBK02Q01_authors.firstName_patch_operation = 'D';
        RBK02Q01_authors.lastName_patch_operation = 'D';

        CALL x_put_data_area_element(data_area_name, element,
                                     element_length);
        IF rc = FAILED THEN GO TO cd_999;

       /*
        * 4. Add a new Author to the Authors array
        *
        * We also want to add a new author to the array so we want to
        * change the fields above slightly.  To specify a new array
        * item we use the '+' symbol as the last element of the
        * _patch_item list. So now we have set up the array to delete
        * one author and add another.  When adding a new array element
        * the _patch_operation fields do not need to be set to any
        * value.
        */
        BAQBASE_RBK02Q01.authors_patch_item = '2,+';
        BAQBASE_RBK02Q01.authors_num = 2;

        RBK02Q01_authors = '';
        RBK02Q01_authors.firstName = 'New';
        RBK02Q01_authors.lastName = 'Author';

        CALL x_put_data_area_element(data_area_name, element,
                                     element_length);
        IF rc = FAILED THEN GO TO cd_999;

       /*
        * 5. Delete the size property as it is not used
        *
        * To remove a property from an object we set its
        * _patch_operation field to 'D' for delete.
        */
        BAQBASE_RBK02Q01.sizeMB_patch_operation = 'D';

       /*
        * 6. Add a 'version' property dynamically and set it to 2.
        *
        * To be able to add new properties dynamically to an existing
        * object the objects schema must specify
        * additionalProperties: true in the OpenApi operation
        * RequestBody schema definition.
        *
        * This setting states the schema object can have extra
        * properties that are not defined by the schema.  Typically
        * these are stored in a Map or Dictionary defined in the Rest
        * API server entity class.
        *
        * For PATCH the way we specify additional properties in COBOL is
        * no different from a PUT or POST operation that supports
        * additional properties, however the generated Patch document
        * consumed by the Rest API is different.
        */

       /*
        * We have now specified a number of field updates in the
        * BAQBASE-RBK02Q01 Request structure we can now make the call to
        * z/OS Connect via the Host API verbs to process the structure
        * and call the endpoint Rest API with a Patch document which
        * will be processed by the API.
        *
        * Here we have chosen to group a number of updates together and
        * process in one call, if desired, each update could be done
        * individually by setting the BAQBASE-RBK02Q01 fields then
        * calling BAQEXEC to call z/OS Connect, then initialize the
        * BAQBASE-RBK02Q01 structure again, update as appropriate and
        * call BAQEXEC again.
        */
       BAQ_REQ_BASE_ADDRESS = ADDR(BAQBASE_RBK02Q01);
       BAQ_REQ_BASE_LENGTH = SIZE(BAQBASE_RBK02Q01);
       BAQBASE_RBK02Q01.requestPathParameters.title =
                  'ABCs of IBM zOS System Programming Volume 1';

 cd_020:
       /*
        * Call the API
        * Passing the address of the API_INFO structure required for the
        * BAQEXEC call. Section x_exec is a reusable routine that is
        * used for all API calls.
        */
       api_info = BAQ_API_INFO_RBK02I01;
       CALL x_exec;

       /*
        * Check that the call was successful, if not exit the section
        * Routine x_exec has displayed the error responses
        */
       IF baq_rc = BAQ_ERROR THEN DO;
          DISPLAY(operation || ' cd_patch_redbook BAQEXEC problem');
          DISPLAY(SUBSTR(BAQ_ZCON_RETURN_MESSAGE,
                         1, BAQ_ZCON_RETURN_MESSAGE_LEN));
          rc = FAILED;
          GO TO cd_999;
       END;

       /*
        * The BAQHAPI has successfully called remote endpoint API and
        * that API has returned a HTTP status code that was defined in
        * the Open API document for the called operation.  This could be
        * an error HTTP status code, but as long as it is defined in the
        * OAS document then BAQHAPI sees this as a successful call so
        * now we must address the returned base structure and
        * interrogate the returned responses in more detail
        *
        * The address of the returned BAQBASE structure is returned in
        * the BAQ_RESPONSE_AREA so set the structure to that address
        */
        BAQBASE_RBK02P01_PTR = BAQ_RESP_BASE_ADDRESS;

       /*
        * For this operation the OAS document defines two responses
        * 200-OK and 404-NOTFOUND, if the remote endpoint application
        * returns any other HTTP status code then a status of
        * BAQ_WARNING is returned and the endpoint response is returned
        * in BAQ_RESP_STATUS_MESSAGE, first 1024 characters.
        *
        * If we have reached here we know the remote endpoint status
        * code is either 404-NOTFOUND or 200-OK. Depending on the status
        * code this determines which Data Area has been returned. See
        * z/OS connect documentation for details on what a Data Area is.
        * In short it is an area of memory that is described by a
        * generated 01 level data structure, it is dynamic in length and
        * used to reference the returned data on a per HTTP status code
        * bases and also for referencing dynamic length arrays.
        */

       /*
        * Check the remote endpoint HTTP status code and check that a
        * response was received, lets do the NOTFOUND case first.
        */
       IF BAQ_RESP_STATUS_CODE = 404 THEN DO;
          IF BAQBASE_RBK02P01.responseCode404_existence > 0 THEN DO;

             /*
              * The Redbook API provided a RedbookNotFound response body
              * in a Data Area, the name of that Data Area is located in
              * responseCode404_dataarea in the BAQBASE data structure.
              * Set this name in to data_area_name and use the common
              * routines x_get_data_area_element and set the expected
              * length of the returned data in element_length.
              */
             data_area_name = BAQBASE_RBK02P01.responseCode404_dataarea;
             element_length = SIZE(RBK02P01_responseCode404);

             CALL x_get_data_area_element(data_area_name, element,
                                          element_length);

             // If rc is failed the BAQGETN call failed
             IF rc = FAILED THEN GO TO cd_999;

             /*
              * BAQGETN has worked and returned the address of the Data
              * Area that contains the RBK02P01_responseCode404 data
              * structure.  Lets address that and display the returned
              * message which should indicate that there are no
              * Red Books in the repository.
              *
              * The RBK02P01_responseCode404 also contains a dynamic
              * array Data Area of authors Red Books, but for this
              * operation this array is not set
              */

             RBK02P01_responseCode404_PTR = element;
             display_message = operation ||
                ' EXEC RESTful EP return HTTP Status Code ' ||
                BAQ_RESP_STATUS_CODE ||
                ' MESSAGE ' || RBK04P01_responseCode404.message;

             CALL x_write_response_msg;
          END;
          ELSE DO;
             /*
              * 404 was returned but there is no RedbookNotFound
              * response body
              */
             display_message = operation ||
                ' EXEC RESTful EP return HTTP Status Code ' ||
                BAQ_RESP_STATUS_CODE ||
                ' NO Response Body';

             CALL x_write_response_msg;
          END;
       END;

       /*
        * Process each returned Redbook. Rather than a single entity in
        * the returned Data Area in this case the OAS response body is
        * an array so rather than a '_existence' flag we have '_num'
        * count that details how many elements exist in the array and
        * we will use x_get_data_area_element to fetch each one in turn.
        */
       IF BAQ_RESP_STATUS_CODE = 200 THEN DO;
          IF BAQBASE_RBK02P01.responseCode200_existence > 0 THEN DO;
             display_message = operation ||
                '  Patched Red Book received';
             CALL x_write_response_msg;

             data_area_name = BAQBASE_RBK02P01.responseCode200_dataarea;
             element_length = SIZE(RBK02P01_responseCode200);

             CALL x_get_data_area_element(data_area_name, element,
                                          element_length);

             // If rc is failed the BAQGETN call failed
             IF rc = FAILED THEN GO TO cd_999;

             RBK02P01_responseCode200_PTR = element;
             display_message = operation ||
                '  URL is now ' || RBK02P01_responseCode200.url;
             CALL x_write_response_msg;

             display_message = operation ||
                '  Contact is now ' || RBK02P01_responseCode200.contact;
             CALL x_write_response_msg;

             display_message = operation ||
                '  Number of authors is ' ||
                RBK02P01_responseCode200.authors_num;
             CALL x_write_response_msg;

             DO i = 1 TO RBK02P01_responseCode200.authors_num BY 1;
                data_area_name = RBK02P01_responseCode200.
                                 authors_dataarea;
                element_length = SIZE(RBK02P01_authors);

                CALL x_get_data_area_element(data_area_name, element,
                                             element_length);

                IF rc = FAILED THEN GO TO cd_999;

                RBK02P01_authors_PTR = element;

               display_message = operation ||
                 '  Author first name ' ||
                  RBK02P01_authors.firstName;
               CALL x_write_response_msg;

               display_message = operation ||
                 '  Author last name ' ||
                 RBK02P01_authors.lastName;
               CALL x_write_response_msg;
             END;
          END;
          ELSE DO;
             display_message = operation ||
                ' EXEC RESTful EP - Redbook not returned';
             CALL x_write_response_msg;
          END;
       END;

 cd_999:
       IF debug = 1 THEN
          DISPLAY(operation || ' cd_patch_redbook Exit' || rc);

    END cd_patch_redbook;

    /*----------------------------------------------------------------*
     * ce_merge_patchbook
     *
     * Operation mergeRedbook - RFC7396
     *
     * Sets the content of the BAQBASE_RBK03Q01 Request structure
     * ready for the BAQEXEC Call. The call is then made to the
     * RESTful End Point(EP) via BAQEXEC and the z/OS Connect server.
     *
     * Upon success, the BAQBASE_RBK03P01 structure is returned
     * and dependent of the EP HTTP Status Code a DATA AREA element
     * is got and processed.
     *----------------------------------------------------------------*/
    ce_merge_redbook: proc;

       IF debug = 1 THEN
          DISPLAY(operation || ' ce_merge_redbook Entry');

       BAQBASE_RBK03Q01.requestBody = '';

       /*
        * Using the PATCH method in an API requests that a server object
        * is updated by a Patch Document on a field by field basis
        * rather then a complete replacement as would happen if using
        * the PUTmethod.
        *
        * This procedure will invoke the mergeRedbook operation in the
        * Redbook management API. Operation mergeRedbook uses media-type
        * application/merge-patch+json which is defined by RFC 7396.
        * This RFC (https://www.rfc-editor.org/rfc/rfc7396) defines
        * the format of the patch document used to update the entity
        * via the Rest API in a server.
        *
        * The patch document is constructed by z/OS Connect based on the
        * settings made to the BAQBASE-RBK03Q01 request structure.
        *
        * Once z/OS Connect has constructed the patch document
        * conforming to the requested media-type (RFC) from the binary
        * COBOL structure this patch document is sent to the Rest API
        * endpoint service. This is received at its path/Patch function
        * and using appropriate function the patch document can be
        * applied to an entity.  See method mergeRedbook in the Java
        * class RedbookResource.java for a Java example that uses
        * Jakarta JsonPatch classes to update a Java Redbook object.
        *
        * In this procedure we are going to set up a request that will
        * produce a patch document that will perform a number of updates
        * on a Redbook object. So for Redbook
        * 'ABCs of IBM z/OS System Programming Volume 2' we are going
        * to update the Redbook to represent a fictitious new version of
        * the Redbook.
        *
        * 1. Update the URL of the Redbooks location.
        * 2. Update the owning departments Contact.
        * 3. Replace the Authors array.
        * 4. Delete the size property as it is not used
        * 5. Add a 'version' property dynamically and set it to 2.
        *
        * These updates show a selection of Patch goals and how we
        * manipulate the operations Request structure to achieve these
        * goals.
        *
        * Lets setup the Request structure BAQBASE_RBK03Q01 then
        * make the call to z/OS Connect via the Host API verbs.
        */

       /*
        * 1. Update the URL of the redbook location
        *
        * Each property defined in the JSON Schema object when
        * translated to COBOL has a field of the same (or similar) name
        * with the suffix _patch_operation for a simple field or sub
        * structure or _patch_item for an array structure.
        *
        * In these fields we set the operation that we want to perform
        * on a particular field, if a _patch_operation field contains a
        * space then no update is made to the property on the Rest API
        * server.  See Patch product documentation for full details.
        *
        * Set the value 'U' for update to the url_patch_operation field
        * and set the new data.
        */
       BAQBASE_RBK03Q01.url_patch_operation = 'U';
       BAQBASE_RBK03Q01.url = 'http://newurl';

       /*
        * 2. Update the owning departments Contact.
        *
        * owningDepartment is a property of type object so this is an
        * example of updating an object within an object.
        *
        * Set the value 'U' for update to the contact_patch_operation
        * field and set the new data for contact.
        *
        * If we wanted to update the whole owningDepartment we could
        * set 'U' in the field ngDepartment_patch_operation and then
        * set the data in each field and the whole property object
        * will update.
        *
        * Note the owningDepartment_patch_operation field has
        * been truncated as the field name is too long to fit. To
        * shorten the _patch_operation to _pchop set the Requester
        * Gradle plugin option shortSuffix: yes. The field will then
        * generate as owningDepartment_pchop.  See the product
        * documentation for details on all the suffixes affected by
        * this option.
        */
        BAQBASE_RBK03Q01.contact_patch_operation = 'U';
        BAQBASE_RBK03Q01.contact = 'A. Contact';

       /*
        * 3. Replace the Authors array
        *
        * With RFC 7396 the array manipulation capabilities are limited,
        * the whole array property can be replaced or the whole array
        * property can be deleted.
        *
        * Here we are going to supply new array content with a single
        * author.
        *
        * In RFC 7396, like the non_array fields, the array has a
        * correspond _patch_operation field, in this case
        * authors_patch_operation.
        *
        * We set the authors_num field to 1 to state there is one array
        * element in the replaced array content
        */
        BAQBASE_RBK03Q01.authors_patch_operation = 'U';
        BAQBASE_RBK03Q01.authors_num = 1;
        BAQBASE_RBK03Q01.authors_dataarea = "AUTHOR-DATA-AREA";

        data_area_name = BAQBASE_RBK03Q01.requestBody.authors_dataarea;
        element = ADDR(RBK03Q01_authors);
        element_length = SIZE(RBK03Q01_authors);

        RBK03Q01_authors = '';
        RBK03Q01_authors.firstName = 'New';
        RBK03Q01_authors.lastName = 'Author';

        CALL x_put_data_area_element(data_area_name, element,
                                     element_length);
        IF rc = FAILED THEN GO TO ce_999;

       /*
        * 4. Delete the size property as it is not used
        *
        * To remove a property from an object we set its
        * _patch_operation field to 'D' for delete.
        */
        BAQBASE_RBK03Q01.sizeMB_patch_operation = 'D';

       /*
        * 5. Add a 'version' property dynamically and set it to 2.
        *
        * To be able to add new properties dynamically to an existing
        * object the objects schema must specify
        * additionalProperties: true in the OpenApi operation
        * RequestBody schema definition.
        *
        * This setting states the schema object can have extra
        * properties that are not defined by the schema.  Typically
        * these are stored in a Map or Dictionary defined in the Rest
        * API server entity class.
        *
        * For PATCH the way we specify additional properties in COBOL is
        * no different from a PUT or POST operation that supports
        * additional properties, however the generated Patch document
        * consumed by the Rest API is different.
        */

       /*
        * We have now specified a number of field updates in the
        * BAQBASE_RBK03Q01 Request structure we can now make the call to
        * z/OS Connect via the Host API verbs to process the structure
        * and call the endpoint Rest API with a Patch document which
        * will be processed by the API.
        *
        * Here we have chosen to group a number of updates together and
        * process in one call, if desired, each update could be done
        * individually by setting the BAQBASE_RBK03Q01 fields then
        * calling BAQEXEC to call z/OS Connect, then initialize the
        * BAQBASE_RBK03Q01 structure again, update as appropriate and
        * call BAQEXEC again.
        */
       BAQ_REQ_BASE_ADDRESS = ADDR(BAQBASE_RBK03Q01);
       BAQ_REQ_BASE_LENGTH = SIZE(BAQBASE_RBK03Q01);
       BAQBASE_RBK03Q01.requestPathParameters.title =
                  'ABCs of IBM zOS System Programming Volume 1';

 ce_020:
       /*
        * Call the API
        * Passing the address of the API_INFO structure required for the
        * BAQEXEC call. Section x_exec is a reusable routine that is
        * used for all API calls.
        */
       api_info = BAQ_API_INFO_RBK03I01;
       CALL x_exec;

       /*
        * Check that the call was successful, if not exit the section
        * Routine x_exec has displayed the error responses
        */
       IF baq_rc = BAQ_ERROR THEN DO;
          DISPLAY(operation || ' ce_merge_redbook BAQEXEC problem');
          DISPLAY(SUBSTR(BAQ_ZCON_RETURN_MESSAGE,
                         1, BAQ_ZCON_RETURN_MESSAGE_LEN));
          rc = FAILED;
          GO TO ce_999;
       END;

       IF baq_rc = BAQ_ERROR THEN DO;
          DISPLAY(operation || ' ce_merge_redbook BAQEXEC problem');
          DISPLAY(SUBSTR(BAQ_RESP_STATUS_MESSAGE,
                         1, BAQ_RESP_STATUS_MESSAGE_LEN));
          rc = FAILED;
          GO TO ce_999;
       END;

       /*
        * The BAQHAPI has successfully called remote endpoint API and
        * that API has returned a HTTP status code that was defined in
        * the Open API document for the called operation.  This could be
        * an error HTTP status code, but as long as it is defined in the
        * OAS document then BAQHAPI sees this as a successful call so
        * now we must address the returned base structure and
        * interrogate the returned responses in more detail
        *
        * The address of the returned BAQBASE structure is returned in
        * the BAQ_RESPONSE_AREA so set the structure to that address
        */
        BAQBASE_RBK03P01_PTR = BAQ_RESP_BASE_ADDRESS;

       /*
        * For this operation the OAS document defines two responses
        * 200-OK and 404-NOTFOUND, if the remote endpoint application
        * returns any other HTTP status code then a status of
        * BAQ_WARNING is returned and the endpoint response is returned
        * in BAQ_RESP_STATUS_MESSAGE, first 1024 characters.
        *
        * If we have reached here we know the remote endpoint status
        * code is either 404-NOTFOUND or 200-OK. Depending on the status
        * code this determines which Data Area has been returned. See
        * z/OS connect documentation for details on what a Data Area is.
        * In short it is an area of memory that is described by a
        * generated 01 level data structure, it is dynamic in length and
        * used to reference the returned data on a per HTTP status code
        * bases and also for referencing dynamic length arrays.
        */

       /*
        * Check the remote endpoint HTTP status code and check that a
        * response was received, lets do the NOTFOUND case first.
        */
       IF BAQ_RESP_STATUS_CODE = 404 THEN DO;
          IF BAQBASE_RBK03P01.responseCode404_existence > 0 THEN DO;

             /*
              * The Redbook API provided a RedbookNotFound response body
              * in a Data Area, the name of that Data Area is located in
              * responseCode404_dataarea in the BAQBASE data structure.
              * Set this name in to data_area_name and use the common
              * routines x_get_data_area_element and set the expected
              * length of the returned data in element_length.
              */
             data_area_name = BAQBASE_RBK03P01.responseCode404_dataarea;
             element_length = SIZE(RBK03P01_responseCode404);

             CALL x_get_data_area_element(data_area_name, element,
                                          element_length);

             // If rc is failed the BAQGETN call failed
             IF rc = FAILED THEN GO TO ce_999;

             /*
              * BAQGETN has worked and returned the address of the Data
              * Area that contains the RBK03P01_responseCode404 data
              * structure.  Lets address that and display the returned
              * message which should indicate that there are no
              * Red Books in the repository.
              *
              * The RBK03P01_responseCode404 also contains a dynamic
              * array Data Area of authors Red Books, but for this
              * operation this array is not set
              */

             RBK03P01_responseCode404_PTR = element;
             display_message = operation ||
                ' EXEC RESTful EP return HTTP Status Code ' ||
                BAQ_RESP_STATUS_CODE ||
                ' MESSAGE ' || RBK04P01_responseCode404.message;

             CALL x_write_response_msg;
          END;
          ELSE DO;
             /*
              * 404 was returned but there is no RedbookNotFound
              * response body
              */
             display_message = operation ||
                ' EXEC RESTful EP return HTTP Status Code ' ||
                BAQ_RESP_STATUS_CODE ||
                ' NO Response Body';

             CALL x_write_response_msg;
          END;
       END;

       /*
        * Process each returned Redbook. Rather than a single entity in
        * the returned Data Area in this case the OAS response body is
        * an array so rather than a '_existence' flag we have '_num'
        * count that details how many elements exist in the array and
        * we will use x_get_data_area_element to fetch each one in turn.
        */
       IF BAQ_RESP_STATUS_CODE = 200 THEN DO;
          IF BAQBASE_RBK03P01.responseCode200_existence > 0 THEN DO;
             display_message = operation ||
                '  Patched Red Book received';
             CALL x_write_response_msg;

             data_area_name = BAQBASE_RBK03P01.responseCode200_dataarea;
             element_length = SIZE(RBK03P01_responseCode200);

             CALL x_get_data_area_element(data_area_name, element,
                                          element_length);

             // If rc is failed the BAQGETN call failed
             IF rc = FAILED THEN GO TO ce_999;

             RBK03P01_responseCode200_PTR = element;
             display_message = operation ||
                '  URL is now ' || RBK03P01_responseCode200.url;
             CALL x_write_response_msg;

             display_message = operation ||
                '  Contact is now ' || RBK03P01_responseCode200.contact;
             CALL x_write_response_msg;

             display_message = operation ||
                '  Number of authors is ' ||
                RBK03P01_responseCode200.authors_num;
             CALL x_write_response_msg;

             DO i = 1 TO RBK03P01_responseCode200.authors_num BY 1;
                data_area_name = RBK03P01_responseCode200.
                                 authors_dataarea;
                element_length = SIZE(RBK03P01_authors);

                CALL x_get_data_area_element(data_area_name, element,
                                             element_length);

                IF rc = FAILED THEN GO TO ce_999;

                RBK03P01_authors_PTR = element;

               display_message = operation ||
                 '  Author first name ' ||
                  RBK03P01_authors.firstName;
               CALL x_write_response_msg;

               display_message = operation ||
                 '  Author last name ' ||
                 RBK03P01_authors.lastName;
               CALL x_write_response_msg;
             END;
          END;
          ELSE DO;
             display_message = operation ||
                ' EXEC RESTful EP - Redbook not returned';
             CALL x_write_response_msg;
          END;
       END;

 ce_999:
       IF debug = 1 THEN
          DISPLAY(operation || ' ce_merge_redbook Exit' || rc);

    END ce_merge_redbook;

    /*----------------------------------------------------------------*
     * x_init
     *
     * Initialize z/OS Connect call by calling BAQINIT this will
     * acquire a connection to a z/OS Connect server and initialise
     * the Host API ready for communication.
     *----------------------------------------------------------------*/
    x_init: PROC;

       IF debug = 1 THEN
          DISPLAY(operation || ' x_init Entry');

       baq_rc = BAQINIT(BAQ_ZCONNECT_AREA);

       IF debug = 1 THEN
          DISPLAY(operation || ' INIT Return Code ' || baq_rc);

       IF baq_rc = BAQ_CRITICAL THEN DO;
          rc = FAILED;
          DISPLAY(operation || ' INIT Return Code FATAL(16)');
       END;

       IF baq_rc != BAQ_SUCCESS THEN DO;
          rc = FAILED;
          DISPLAY(operation || ' INIT Completion Code '
                           || BAQ_ZCON_COMPLETION_CODE);
          DISPLAY(operation || ' INIT Reason Code '
                           || BAQ_ZCON_REASON_CODE);
          DISPLAY(operation || ' INIT Return message '
                           || BAQ_ZCON_RETURN_MESSAGE);
       END;

       // Check for bad initialisation
       IF baq_rc != BAQ_SUCCESS THEN DO;
          display_message = operation  ||
                 ' INIT failed' ||
                 ' CC=' || BAQ_ZCON_COMPLETION_CODE ||
                 ' RC=' || BAQ_ZCON_REASON_CODE;

          CALL x_write_response_msg;

          DISPLAY(SUBSTR(BAQ_ZCON_RETURN_MESSAGE, 1,
                         BAQ_ZCON_RETURN_MESSAGE_LEN));

           rc = FAILED;
       END;

       IF debug = 1 THEN
          DISPLAY(operation || ' x_init Exit' || rc);

    END x_init;

    /*----------------------------------------------------------------*
     * x_exec
     *
     * Make the BAQEXEC call
     *----------------------------------------------------------------*/
    x_exec: PROC;
       DCL fail_type CHAR(18);

       IF debug = 1 THEN
          DISPLAY(operation || ' x_exec Entry');

       baq_rc = BAQEXEC(BAQ_ZCONNECT_AREA,
                        api_info,
                        BAQ_REQUEST_AREA,
                        BAQ_RESPONSE_AREA);

       IF debug = 1 THEN
          DISPLAY(operation || ' EXEC Return Code ' || baq_rc);

       IF baq_rc = BAQ_CRITICAL THEN DO;
          rc = FAILED;
          DISPLAY(operation || ' EXEC Return Code FATAL(16)');
       END;

       IF baq_rc != BAQ_SUCCESS THEN DO;
          rc = FAILED;
          DISPLAY(operation || ' EXEC Completion Code '
                           || BAQ_ZCON_COMPLETION_CODE);
          DISPLAY(operation || ' EXEC Reason Code '
                           || BAQ_ZCON_REASON_CODE);
          DISPLAY(operation || ' EXEC HTTP Status Code '
                           || BAQ_RESP_STATUS_CODE);
          DISPLAY(operation || ' EXEC Return message '
                           || BAQ_ZCON_RETURN_MESSAGE);
       END;
       ELSE DO;
          IF debug = 1 THEN
             DISPLAY(operation || ' EXEC HTTP Status Code '
                               || BAQ_RESP_STATUS_CODE);
       END;


       IF baq_rc != BAQ_SUCCESS THEN DO;
          SELECT(baq_rc);
             WHEN(BAQ_WARNING)
                fail_type = 'API RETURN WARNING';
             WHEN(BAQ_ERROR)
                fail_type = 'API RETURN ERROR  ';
             WHEN(BAQ_SEVERE)
                fail_type = 'API RETURN SEVERE ';
          END;

          display_message = operation || ' EXEC failed with ' ||
             fail_type || ' CC=' || BAQ_ZCON_COMPLETION_CODE ||
             ' RC=' || BAQ_ZCON_REASON_CODE;

          CALL x_write_response_msg;

          DISPLAY(operation || ' ' || SUBSTR(BAQ_ZCON_RETURN_MESSAGE, 1,
                        BAQ_ZCON_RETURN_MESSAGE_LEN));
        END;
        ELSE DO;
           IF debug = 1 THEN
              DISPLAY(operation || ' EXEC Status Code ' ||
                   BAQ_RESP_STATUS_CODE);
        END;

       IF debug = 1 THEN
          DISPLAY(operation || ' x_exec Exit' || rc);

    END x_exec;

   /*----------------------------------------------------------------*
     * x_put_data_area_element
     *
     * Puts a Data Element in to the Data Area named in the variable
     * data_area_name using address element_ptr and length
     * element_length.
     *
     * Calls BAQPUTN (Put Next) which returns baq_rc.
     *----------------------------------------------------------------*/
    x_put_data_area_element: PROC(data_area_name, element_ptr,
                                  element_length);

       DCL data_area_name CHAR(16);
       DCL element_ptr PTR;
       DCL element_length fixed bin(31);

       IF debug = 1 THEN
          DISPLAY(operation || ' x_put_data_area_element(' ||
                  data_area_name || ') Entry');

       baq_rc = BAQPUTN(BAQ_ZCONNECT_AREA,
                        data_area_name,
                        element_ptr,
                        element_length);

       IF baq_rc  != BAQ_SUCCESS THEN DO;
          rc = FAILED;
          DISPLAY(operation || ' PUTN Return Code ' || baq_rc);
          DISPLAY(operation || ' PUTN See STDOUT/STDERR for details');

          IF debug = 1 THEN DO;
             DISPLAY(operation || ' PUTN Completion Code ' ||
                                 BAQ_ZCON_COMPLETION_CODE);
             DISPLAY(operation || ' PUTN Reason Code ' ||
                                 BAQ_ZCON_REASON_CODE);
          END;

          display_message = operation ||
                 ' PUTN failed' ||
                 ' CC=' || BAQ_ZCON_COMPLETION_CODE ||
                 ' RC=' || BAQ_ZCON_REASON_CODE;

          CALL x_write_response_msg;

          DISPLAY(operation || ' PUTN Return message '
                           || BAQ_ZCON_RETURN_MESSAGE);
       END;

       IF debug = 1 THEN
          DISPLAY(operation || ' x_put_data_area_element Exit' || rc);

    END x_put_data_area_element;

    /*----------------------------------------------------------------*
     * x_get_data_area_element
     *
     * Gets a Data Element from the Data Area named in the variable
     * data_area_name using length element_length.
     *
     * Calls BAQGETN (Get Next) which sets element_ptr to the address
     * of the data element retrieved.
     *----------------------------------------------------------------*/
    x_get_data_area_element: PROC(data_area_name, element_ptr,
                                  element_length);

       DCL data_area_name CHAR(16);
       DCL element_ptr PTR;
       DCL element_length fixed bin(31);

       IF debug = 1 THEN
          DISPLAY(operation || ' x_get_data_area_element(' ||
                  data_area_name || ') Entry');

       element_ptr = SYSNULL();
       baq_rc = BAQGETN(BAQ_ZCONNECT_AREA,
                        data_area_name,
                        element_ptr,
                        element_length);

       IF baq_rc  != BAQ_SUCCESS THEN DO;
          rc = FAILED;
          DISPLAY(operation || ' GETN Return Code ' || baq_rc);
          DISPLAY(operation || ' GETN See STDOUT/STDERR for details');

          IF debug = 1 THEN DO;
             DISPLAY(operation || ' GETN Completion Code ' ||
                                 BAQ_ZCON_COMPLETION_CODE);
             DISPLAY(operation || ' GETN Reason Code ' ||
                                 BAQ_ZCON_REASON_CODE);
          END;

          display_message = operation ||
                 ' GETN failed' ||
                 ' CC=' || BAQ_ZCON_COMPLETION_CODE ||
                 ' RC=' || BAQ_ZCON_REASON_CODE;

          CALL x_write_response_msg;

          DISPLAY(operation || ' GETN Return message '
                           || BAQ_ZCON_RETURN_MESSAGE);
       END;

       IF debug = 1 THEN
          DISPLAY(operation || ' x_get_data_area_element Exit' || rc);

    END x_get_data_area_element;


    /*----------------------------------------------------------------*
     * x_free
     *
     * Free any storage used by BAQEXEC
     *----------------------------------------------------------------*/
    x_free: PROC;

       IF debug = 1 THEN
          DISPLAY(operation || ' x_free Entry');

       baq_rc = BAQFREE(BAQ_ZCONNECT_AREA);

       IF baq_rc  != BAQ_SUCCESS THEN DO;
          rc = FAILED;
          DISPLAY(operation || ' FREE Return Code ' || baq_rc);
          DISPLAY(operation || ' FREE See STDOUT/STDERR for details');

          IF debug = 1 THEN DO;
             DISPLAY(operation || ' FREE Completion Code ' ||
                                 BAQ_ZCON_COMPLETION_CODE);
             DISPLAY(operation || ' FREE Reason Code ' ||
                                 BAQ_ZCON_REASON_CODE);
          END;

          display_message = operation ||
                 ' FREE failed' ||
                 ' CC=' || BAQ_ZCON_COMPLETION_CODE ||
                 ' RC=' || BAQ_ZCON_REASON_CODE;

          CALL x_write_response_msg;

          DISPLAY(operation || ' FREE Return message '
                           || BAQ_ZCON_RETURN_MESSAGE);
       END;

       IF debug = 1 THEN
          DISPLAY(operation || ' x_free Exit' || rc);

    END x_free;

    /*----------------------------------------------------------------*
     * x_term
     *
     * Terminates the connection to z/OS Connect using BAQTERM.
     *----------------------------------------------------------------*/
    x_term: PROC;

       IF debug = 1 THEN
          DISPLAY(operation || ' x_term Entry');

       // Terminate the connection
       baq_rc = BAQTERM(BAQ_ZCONNECT_AREA);

       IF baq_rc  != BAQ_SUCCESS THEN DO;
          rc = FAILED;
          DISPLAY(operation || ' TERM Return Code ' || baq_rc);
          DISPLAY(operation || ' TERM See STDOUT/STDERR for details');

          IF debug = 1 THEN DO;
             DISPLAY(operation || ' TERM Completion Code ' ||
                                 BAQ_ZCON_COMPLETION_CODE);
             DISPLAY(operation || ' TERM Reason Code ' ||
                                 BAQ_ZCON_REASON_CODE);
          END;

          display_message = operation ||
                 ' TERM failed' ||
                 ' CC=' || BAQ_ZCON_COMPLETION_CODE ||
                 ' RC=' || BAQ_ZCON_REASON_CODE;

          CALL x_write_response_msg;

          DISPLAY(operation || ' TERM Return message '
                           || BAQ_ZCON_RETURN_MESSAGE);
       END;

       IF debug = 1 THEN
          DISPLAY(operation || ' x_term Exit' || rc);

    END x_term;

    /*----------------------------------------------------------------*
     * Write messages to console
     *----------------------------------------------------------------*/
    x_write_response_msg: PROC;

       DISPLAY(display_message);
       display_message = REPEAT(' ', 77);

    END x_write_response_msg;
 END;
